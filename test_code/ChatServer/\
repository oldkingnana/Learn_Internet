#include "ChatServer.hh"
#include "myeasylog.hpp"

#include <queue>
#include <string>
#include <utility>

void oldking::ChatServer::start()
{
	// 这里其实并没有做到接收与发送解耦，后续会改一个解耦的版本
	// 顺带一提，消息队列其实是为了解耦而生的
	// 因为如果没有解耦，那其实只需要借用socket自带的队列就行了
	// 换句话说我的主线程既启动和死循环ChatServer服务，又负责recv消息
	while(true)
	{
		get_msg_();

		for(const auto& it : client_map_)
		{
			task_arg* arg = new task_arg
			{
				this,
				waiting_queue_.front().first, 
				it.first,
				it.second
			};

			if(waiting_queue_.front().second != it.first)
				TP_.SendTask(send_task_, (void*)arg);
			else 
				delete arg;
		}
		waiting_queue_.pop();
	}
}

void oldking::ChatServer::get_msg_()
{
	oldking::MyEasyLog::GetInstance().WriteLog(
			LOG_INFO,
			"ChatServer",
			"get_msg_ begin");

	std::string buff;
	std::string sender_ip;
	int16_t sender_port;
	Udp_->recv(
			buff, 
			sender_ip, 
			sender_port
			);

	oldking::MyEasyLog::GetInstance().WriteLog(
			LOG_DEBUG,
			"ChatServer",
			"buff: " + buff + " ip: " + sender_ip + " port: " + std::to_string(sender_port));

	if(client_map_.find(sender_ip) == client_map_.end())
	{
		client_map_[sender_ip] = sender_port;	
		oldking::MyEasyLog::GetInstance().WriteLog(
				LOG_DEBUG,
				"ChatServer",
				std::string("new client   ") + " ip: " + sender_ip + " port: " + std::to_string(sender_port));
	}
	else if(client_map_[sender_ip] != sender_port)
	{
		client_map_[sender_ip] = sender_port;	
		oldking::MyEasyLog::GetInstance().WriteLog(
				LOG_DEBUG,
				"ChatServer",
				std::string("new client   ") + " ip: " + sender_ip + " port: " + std::to_string(sender_port));
	}

	waiting_queue_.emplace(std::move(buff), std::move(sender_ip));
	
	oldking::MyEasyLog::GetInstance().WriteLog(
			LOG_INFO,
			"ChatServer",
			"get_msg_ finish");
}
		
void oldking::ChatServer::send_msg_(const std::string& msg, const std::string& ip, const int16_t port)
{
	oldking::MyEasyLog::GetInstance().WriteLog(
			LOG_INFO,
			"ChatServer",
			"send_msg_ begin");

	oldking::MyEasyLog::GetInstance().WriteLog(
			LOG_DEBUG,
			"ChatServer",
			"msg: " + msg + " ip: " + ip + " port: " + std::to_string(port));

	Udp_->send(ip + ": " + msg, ip, port);		
	
	oldking::MyEasyLog::GetInstance().WriteLog(
			LOG_INFO,
			"ChatServer",
			"send_msg_ begin");
}

void* oldking::ChatServer::send_task_(void* arg)
{
	auto pinfo = (task_arg*)arg;

	// 其实一个类的静态方法有权限访问一个类的其他非静态方法
	// 但因为静态方法不允许拥有this指针，所以一般情况下会没有权限访问
	// 如果我们实际传一个类的指针进来，那就可以访问了
	(*pinfo).self->send_msg_(
			(*pinfo).msg,
			(*pinfo).ip,
			(*pinfo).port
			);

	delete pinfo;

	return nullptr;
}


