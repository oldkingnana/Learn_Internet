### 1 简单了解网络

* 本小节,我们将简单了解一下,或者说见识一下网络究竟是什么,以及常见的思想

#### 1.1 网络通信的本质

* 在现代设计中,网络通信绝大多数都是以字节流进行通信的
* 网络通信本质上其实是多主机之间进行通信,每个主机拥有自己的独立IP地址(严格意义上不能这么形容,但是我们可以大概这么理解),通过这个独立的IP地址,每个接入网络的设备就可以通过这个IP访问其他设备

#### 1.2 通信方案举例

##### 1.2.1 `HTTP`

* 比方说网页页面的获取,就是使用`HTTP`协议进行的

* 假设我们需要获取一个网页,本质上就是向某个IP地址的主机发送一串字节,这个字节流全是以`ASCII`字符构成,所以这些内容完全是可读的

* 然后该主机会接收这串字节,并做检验,完全通过后就可以回传一串字节,表示允许获取内容,然后表示允许获取的字节后面将会紧接着网页页面文件的文本一并以字节流/二进制返回,写入到用户的浏览器或者说内存中,浏览器将这一大片文本(本质上是前端代码)渲染成实际的图形页面,这样用户就能访问网页了

##### 1.2.2 `BitTorrent`(`BT`协议)

* 这种通信方式也是一种常用的通信方式,迅雷本质上也是用这种方式,实现网络通信的
* 在`BitTorrent`协议中,本质上不存在严格意义上的"服务端",所有主机都作为客户端,更严格意义上说,所有主机都是客户端,也都是服务端
* 我们知道,从迅雷等等以`BitTorrent`协议为基础的软件中下载东西,都需要一个叫做磁力链接的东西,这个磁力链接会直接以`Hash`的方式直接和文件进行对应
* 然后我们会在互联网中寻找谁在线且有这个`Hash`,只要找到一个人有这个`Hash`,我们就会寻找该主机中,曾今还访问过哪些其他主机的`Hash`,这样,即便我们没有进行下载,我们也知道互联网中有谁还有这个文件(当然,前提是这些主机都在线)
* 接着就建立连接,开始在各个主机中下载文件
* 当然,这样有利也有弊,因为所有主机既是客户端又是服务端,那么意味着每台主机的上传量都不低
* 同时,并不是所有主机中,都完整存有这个文件,于是每个文件都会被切分成若干个`piece`,我们在与其他主机建立连接后,会交换主机拥有的`piece`信息
* 优先下载所有建立联系的主机中,最稀有的`piece`,尽可能保证该`piece`不会缺失
* 只要所有`piece`都存在,就一定能获取完整的文件,同时还能并行下载,提高下载速度

* 我们再说得更详细些
* 如果我们需要通过一个磁力链接/种子文件下载文件,这个链接/文件多数情况下是你通过`HTTP`下载网页或是下载文件得到的,而使用它,首先必须要经过一个有`tacker`的主机(一个主机可能会存放多个`tracker`),每个磁链链接或者说每个`Hash`会对应一个`tracker`,这个`tracker`不包含文件本身,所以说`tracker`其实不提供下载服务,但他能告诉用户,当前`tracker`中,有哪些用户在线
* 换句话说,这个磁力链接/种子文件告诉你的其实不是文件本身,也不是某个在线的用户地址,而是一个`tracker`的位置信息,通过`tracker`来找到其他用户
* 所以,宏观来看,这所有的用户共同构成了一个集群,而`tracker`扮演的角色仅仅只是记录用户在线情况,还有`Hash`对应哪部分文件,且帮助用户找资源,仅此而已
* 至于交换信息,则是集群中的用户该干的事情,他们使用双向的`byte`流进行数据交换,`tracker`本身不参与实际的数据交换

* 这也是为什么`BitTorrent`协议的核心思想是`P2P`(`peer to peer`)

* 值得注意的是,磁力链接其实仅记录`tracker`的位置,而种子文件则在此基础上,还会记录文件结构和`piece`情况等等
* 而用户第一次通过磁力链接或是种子文件与`tracker`建立联系时,也是通过`HTTP`协议进行沟通的,至于用户与用户之间沟通,则是用的`BitTorrent`的专有协议

* 所以,我们在使用诸如`qBittorrent`等工具的时候,可以通过一些渠道获取足够的`tracker`,以提升某个文件的下载速度和同时在线的用户量

##### 1.2.3 `Skype`独特的通信方式

* 在了解`skype`的通信机制之前,我们首先需要了解一个概念,即`NAT`
* `NAT`,本质上就是家里的路由器,路由器为你分配私有IP地址,且如果主机通过路由器接入互联网,那么外界的陌生主机无法主动获取私有主机的数据,因为会被`NAT`拦截
* 如果私有主机通过了`NAT`访问了外部设备,那么这个外部设备不再设为陌生设备,而是类似于进入`NAT`的白名单中,于是这个外部设备也能够获取私有主机的数据了,实现了既保证用户安全,又能实现数据交换的设想

* 但问题来了,这里我们要讨论一个问题,即"如果主机在`NAT`后,还能不能实现`P2P`?"
* 我们来看一个图
![[Pasted image 20250901171758.png]]

* 首先,`NAT`后的`client B`登录并上线`skype`,此时`client B`主动与`server`交流,于是`server`与`client B`允许交换资源
* 然后不在`NAT`后的`client A`也登录并上线`skype`,此时`client A`与`server`也可以交换资源
* 此时`client A`拨打电话给`client B`,因为`client B`在`NAT`后,所以`client A`不能直接给`client B`打电话,因为`NAT`认为`client A`是一个陌生设备
* 所以由已经不是陌生设备的`server`帮忙转发`call`给`client B`,此时`client B`会提示有人拨打电话给自己
* 如果`client B`接听了电话,此时`client B`会发送一个请求给`client A`,那么`client B`和`client A`的第一次有效沟通其实是由`client B`主动完成的
* 此时`client A`和`client B`就可以实现`P2P`式的数据交换了
* 所以你发现了吗,即便是`client B`在`NAT`后,也可以实现`P2P`式数据交换,根本解决思路来自于:由已经允许数据交换的`server`代理转发"其他设备希望数据交换的任务",从而让`NAT`后的设备主动访问这个其他设备
* 非常巧妙
* 我们称这种代理`server`为`Rendezvous Server`(会合服务器)

* 如果`client A`也在`NAT`后还可以实现`P2P`吗?
* 答案是不行,因为让`client B`发送请求给`client A`,它也收不到,会被拦截
* 所以在这种情况下,会退化成中继服务器转发操作,即`client`只与`server`交换数据,转发数据给其他`client`由`Relay Server`完成

#### 1.3 计网的四层结构以及"跳转"

* 在现代计算机网络的概念中,我们将整个网络分为四个层,当然,了解完这个小节之后,你仍然可能云里雾里,这是正常的,我们只是了解一下大纲而已

* 在此之前,我们首先需要了解一个概念
* 现代计算机网络中,绝大部分情况下,数据的传输绝对不是两点一线地传输的,它更像是一张网,数据在网上的节点不停跳转,直到到达目的地
* 就像是现代的物流网络一样,包裹的下一站不一定就是目的地,也可能是另一个中转站点,计算机中的网络也一样,下一跳不一定是目的地,但一定会接近目的地

![[Pasted image 20250901212352.png]]

* 具体分为以下四层

![[Pasted image 20250901211220.png]]

1. `Link`: 这一层也被称为链路层,这一层负责实际的传输任务,它不在乎究竟怎么传数据,仅负责传输功能本身
2. `Network`: 这一层也被称为网络层,这一层负责检测/指定传输目标,换句话说就是将`data`和目的地打包成一个`packet`,或者解包`packet`并分析目的地,换句话说,规定目的地的是`Network`,`Link`仅为`Network`提供发送服务,具体要发送到哪里取决于`Network`是怎样设定的
3. `Transport`: 也被称为传输层,这一层的设计初衷其实很简单,是为了弥补`Network`层的一些设计缺陷,计网功能的设计中,很多地方秉承着尽可能解耦的原则,换句话说,`Transport`层其实更像是`Network`层的插件(可以从这个角度看但不能严格这么理解),以实现更多复杂的功能,`Network`层其实不能保证传输一定不会失败,`Network`只能保证传输尽可能成功,如果拥塞非常严重,那么数据丢失也是板上钉钉的事情,所以需要`Transport`层做更多的功能,比方说检测到丢包就进行重传操作等等,这种重传操作的规范,我们称作`TCP`协议,比方说我们看视频的时候,为了保证每一个视频片段都能完整播放,就需要使用`TCP`协议保证`packet`能完整传输,当然也有不需要完整传输的情况,比方说视频电话,这种情况下,重传其实是没有任何意义的,因为视频电话讲究严格同步,不能延迟太高,所以不如直接让其丢失,反映在用户上则可能就是视频卡顿或者模糊等等,这种允许不保证`packet`完整传输的规范称为`UDP`协议
4. `Application`: 这一层也被称为应用层,用于规范数据如何交换,或者说作为数据交换的架构,比方说我们之前聊的`HTTP`协议和`Bittorrent`协议都在这一层,或者说这一层是用于规范数据交换策略的

* 值得一提的是,我们所说的路由器,也在这个传输网络中
* 路由器中只存在`Link`和`Network`这两层(这个地方其实不太准确,我们会进行补充),`Network`用于解包`packet`并计算下一跳的位置,而`Link`则负责传输,至于其他两层,路由器不需要也不在乎,因为路由器的本职工作是"路由",即找到下一跳位置并进行传输

![[Pasted image 20250901220412.png]]

* `Application`层负责宏观控制如何进行数据交换,然后向下,以指定的`Transport`协议进行数据传输,同样的,`Transport`也会向下指定`Network`进行对应的数据封装形成`packet`,并同样向下要求`Link`传输包到下一跳(事实上`Application`和`Transport`多半也是封装包的过程,只是封装的内容除了接收者,其他中继的硬件看见了也没有任何意义,如果中继硬件能够看到,反倒会使中继硬件维护/设计成本增加,也不够解耦,所以中继硬件被设计成非常傻瓜解耦的仅支持寻找地址+转发的模式)
* 所以说,对于数据的发送者而言,这四层其实就是一个层层打包的过程
* 而对于接收者而言,则就是层层解包的过程

* 在这里我们就有必要提一提"端到端"(end-to-end)和"跳到跳"(hop-to-hop)的概念了
* 端到端本质的服务对象其实是数据的发送者和接收者,即通信链路的两端,端到端思想本身不在乎中间经过了多少跳,而只在乎数据是否完整,数据符合什么应用层协议
* 跳到跳服务的对象则是所有作为跳的中继硬件,即通信链路属于中间的部分,该思想不在乎具体有没有丢失数据,也不在乎怎么处理数据,只负责定位+转发
* 所以说,本质上围绕端到端的是`Application`和`Transport`,而围绕跳到跳的则是`Network`和`Link`

* 我们视野拉开些看,目前我们所知道的协议

* `Application`: `HTTP`,`Bittorrent`等等
* `Transport`: `TCP`,`UDP`等等

* 我们知道,一个数据在`Network`被打包的时候会添加进目的地址(当然,其实还会添加发送地址),这个过程我们称为`IP`(Internet protocol)协议,`IP`协议不保证一定能不丢失数据,不保证顺序正确,也不保证数据不会重复,并且,整个`Network`就只有这一个协议,没有其他个性化的方案,因为仅使用这个方案就完全足够了,简单,统一,傻瓜,易用!

* 至于`Link`,也有很多其他的协议,比方说`4G`,`5G`,`WIFI`等等

* 所以宏观来看,整个自上而下的四层就像是一个漏斗一样,上下都可以走各式各样功能丰富的协议,但中间的`Network`一定只能走`IP`协议
* 这也是`IP`为什么这么重要的原因

#### 1.4 浅谈`IP`协议

* 在了解`IP`协议本身之前,我们先来谈谈`IP`协议的几个特点(虽然上一小节已经谈论过一部分了),以及这些特点为`IP`协议带来了什么

* 显著的是,`IP`协议是面向跳到跳的协议,`IP`协议只负责转发相关的内容,完全不负责数据中存储了什么,也不负责如何处理数据
* 并且,`IP`协议不可靠,`IP`不会保证一定能不丢失数据,不保证一定不会重复数据,他只能尽可能保证数据正确,除非阻塞严重,一旦拥塞严重,`IP`协议认为丢失该包也是正常操作,它不会做检查,也不会重发
* 同时也正因如此,我们常说路由器参照`IP`协议用于转发包,但实际上路由器也可能会因为设置错误而导致转发到不该转发的机器上(本质上,关于路由器如何知道该怎么转发这一点,路由器自身内部有一个转发表,用于判断应该往哪个方向转发,但这个表终归还是人类设计的,不可能不出错对吧),所以`IP`协议也不能保证转发一定成功

* 所以,如你所见,这个我们所称的"`IP`协议"似乎一点也不"协议",它一点也不复杂,甚至说有些懒惰,它啥也不检查,啥也不关心,只是自顾自地转发数据报,转发不了就丢弃
* 但正是因为足够简单,足够傻瓜,才能让其能变成全球通用的互联网协议,才能让其能遍布全球,轻而易举地变成"网络"
* 同时因为足够简单,所以对于网络中的中继硬件来说,其构造也会足够简单,也会更容易维护,更加容易进行升级,至于更多的功能,放到传输的两个端点去进行吧

* 当然,这里我们提到了数据报(datagram),我们需要对其做一些解释
* 我们在之前的小节中提到过,数据在发送之前,会经过四层打包,最开始在`application`,`datagram`仅由需要传输的数据构成,本质上就是一个字符串或者说二进制串,向`transport`打包后,字符串的头会被添加一串字符/数据,用于标示使用的什么`transport`协议,同样的,在`Network`层,也会添加一串字符/数据用于标示数据来源(`IPSA` "IP source address")和目的地(`IPDA` "IP destination address"),`Link`层也是如此,添加一串用于标示传输方式的字符/数据
* 我们称数据报自上而下四层打包,最后在链路层被打包为`frame`(帧)

* 同时,`IP`协议其实也不在乎`Link`层是怎样传输的,能传输就行,所以,CS144课程中提到,你甚至可以用信鸽作为传输介质hh

* 我们简单谈一谈`IP`协议的一些细节问题
* 我们知道,数据包在网络中传输,所以势必的,可能就会出现无限循环传输的情况,所以`IP`协议用一个字段描述还剩下多少次跳转机会,称为`TTL`(Time To Live),初始值为`64`/`128`/`...`,每次跳转就会`-1`,如果为`0`时还没有送达到,那么这个`data packet`(数据包)就会被丢弃
* 同时,`IP`协议也会尽可能保证`data packet`被正确路由,为此`IP`协议再次添加了一个字段用于简单校验
* `IP`协议现在有两种,一种是`32 bit`的`IPV4`,另一种是`128 bit`的`IPV6`,因为网络发展非常快,所以现在,`IPV4`地址已经快要用完了,目前更多人都在转移到`IPV6`
* 当然,`IP`协议也不是不可扩展功能的,它也留有了一定字段允许扩展其功能,只是几乎没有人会这么干就是了

#### 1.5 简单看看网络中的"包"

* 如你所见,在上一小节中我们提到了很多类似于"包"的专有名词,我觉得有必要了解一下这些名词的区别,否则看懂上一节其实会相对困难一点点

1. `message`: 报文,这是我们最原始的数据,是最初的还没有被网络部分做任何打包的数据,可能由字符流或者二进制流构成,对于目标主机的对应进程而言,它是完全可读的
2. `datagram`: 数据报,对于`Transport`和`Network`这两层而言,`datagram`是基本传输单位,当然我们只是叫他这个名字而已,实际运用还是很简单的,所以根据协议类型,我们可以在`Transport`中分为`UDP datagram`之类的(严格来说没有`TCP datagram`),然后向下被打包成`IP datagram`
3. `frame`: 帧,这是`Link`传输的基本单位,由`datagram`打包而成
4. `data packet`: 数据包,这其实是一个泛称,用来指所有在网络中传输的东西

#### 1.6 包是怎样传输的

* 我们知道,`data packet`会从某个主机发送给另一个主机,当然这个`data packet`可能多半是一个`frame`,因为`frame`是`Link`层的基本传输单位

* 当我们将其传输到一个路由中,路由会将其解包(本质上其实不算是解包,而是读某一段固定区间),然后路由会取出其中的`IPDA`,并查一个叫路由表的东西

* 这个表并不会记录完整的`IP`地址,而是记录一个相对模糊的方向,类似于这样

|类型|目标链路|
| :---: | :---: |
| default | Link0 |
| 类型1 | Link1 |
| 类型2 | Link2 |
| 类型3 | Link3 |
| 类型4 | Link4 |
| 类型5 | Link5 |

* 然后路由器会根据`IP`,找到最匹配的类型,然后发送给对应的下一跳或者对应的目标链路
* 但是,总会有完全不符合所有匹配类型的情况
* 此时,路由器会将其匹配到默认路由,也就是`default`,会将其发送给更大的网络以期望其能够正确匹配目标链路

* 我们就拿CS144课程的例子来说

* 一个`data packet`从学校机房中发出,他会经过机房的路由,路由中可能记录了学校内的部分其他路由,比方说餐厅的路由或者是图书馆的路由
* 如果我的目标就是学校内的其他设备,那我可以直接使用路由表中设定的类型,并下一跳到餐厅或者图书馆之类的路由,再由它们进行直接转达

* 但如果我的目标地址不是学校中的设备,且路由表中找不到任何能够匹配的类型,那么下一跳就会走默认路由,可能会发送给运营商的路由/数据中心的路由以期望在下一跳中能获取到更全面的路由表

#### 1.7 `TCP`协议在数据传输中的作用

* 在前面几个小节中,我们已经了解过了,`TCP`是一种可靠字节流的传输协议,底层的`IP`协议为其提供服务
* 你可能在学习或者一些科技向视频中有了解过,构建一个`TCP`传输"通道"之前,需要进行三次握手
* 就类似于这样：
	1. 客户端发送`SYN`(synchronize)标志位给服务器,表示我想和你建立连接
	2. 服务器发送`SYN`标志位和`ACK`(acknowledge)标志位回客户端,表示我也想和你建立连接,并且我已经准备好了
	3. 客户端发送`ACK`标志位给服务器,表示我也准备好了
* 至此,客户端和服务端就建立了可靠的`TCP`连接(当然,`TCP`的"可靠"不全部源自于三次握手,三次握手只是保障可靠的重要条件之一)

* 另一个问题,我们需要搞清楚"端口"(`port`)
* 我们已经知道,我们可以通过一个`IP`地址找到一个主机,但主机上可能跑着很多服务,我们怎么知道要访问哪个服务呢?
* 于是我们需要端口帮我们进行区分
* 同一个`IP`下,不同的`Transport`协议的不同端口可能对应着的不同的服务,这里我们仅拿`TCP`进行举例
* 比方说在`80`号端口,就是默认的`HTTP`服务的端口,又或者说我访问油管,其服务的默认端口可能是`443`这种

* 换句话说,我们需要获取到一个对应的服务,应该使用`IP`和`port`的组合,才能允许获取对应服务,至于具体是怎么获取到这个`IP`和`port`的,我们暂时不需要特别清楚,但可以提的是,这两个东西是通过解析域名得到的


#### 1.8 分组交换(Packet switching)

* 如你所见,如果我们直翻"Packet switching",那么应该叫包交换,但实际上这个词和中文语境下的"交换"没有啥关系,同时,"包"这个词在这里也有些出入
* 首先输出一个结论
	1. 在这个思想中,"包"是手段,"分组"是目的
	2. 在计算机网络的语境中,这里的"交换"其实指数据的转发

* 分组交换是现代计算机网络的设计思想
* 在更加早期的数据传输技术中,人们普遍是用电话线进行数据传输,换句话说就是打电话
* 电话线优势很明显,就是一旦建立连接,就几乎不存在数据中断,但缺点也很明显,这条电话线会被两个通信端点独占,其他任何人都没法共享这个电话线,那么,电话线这个资源就是不可分割的,即便你打电话的时候一句话都不说,电话线也会被你一直占用,这就导致资源的浪费,这种浪费在当今网络是非常致命的
* 试想一下,假设路由器的网络带宽也是一个不可分割资源,那么一旦你的室友在下载电影或者下载游戏,那么你的电脑就访问不到任何网络,只能等待你的室友断开网络连接
* 所以我们需要一种方式,能让信号的传输介质变得可共享
* 于是,分组交换思想就应运而生了
* 我们将数据切割成小块,然后打包,发送
* 于是,就会有一个现象,当你空闲的时候,路由就会停止向我转发数据包,如果此时有其他人需要路由转发数据包,那么路由就可以轻松帮助他转发
* 同时,如果两个人同时需要路由,那么路由器也会尽可能公平,他会尽可能保证公平地转发数据包,比方说当前`ms`可能向我转发数据包,那么下一`ms`,就会向共享路由的另一个人转发数据包,再下一次又是向我转发数据包
* 所以你发现了吗,路由此时在人类眼里看来,就像是一个可以分配的资源一样,或者说就像是蛋糕一样,可以被切分给所有共享者,这种将单一资源以概率或统计的方式在多个用户中共享的思想被称为"统计复用"(Statistic Multiplex)
* 我们换一个更加简单的场景,我们将路由器想象成`CPU`一样的资源,那么如果实现多线程,多线程会平分这个`CPU`资源,所以,核心思想其实一直都没有变,都是为了尽可能减少资源浪费,尽可能始终让设备一直高效运行,从而提高整体的运行效率
* 拆分成包的另一个优势是,我们在端点,不需要在乎组成一个文件的所有包,都是怎样在中途转发过来,换句话说,我们不需要在乎各个包在哪条路径上转发的,甚至不需要在乎包是否按顺序到达,只需要在端点解包并将打散的数据重排就行(重排是`Transport`层协议关心的事情)
* 并且,哪怕两端主机已经建立了TCP链接,实际数据包在中途的传输中,也不会按照既定线路,而可能会分发到多个路由,最后汇总到目标地址

* 来自维基百科:
![[Packet_Switching.gif]]

* 并且,`IP`协议就是严格按照该思想设计的
* 这使得每一跳的逻辑都很简单,路由也可以很简单,但却可以在底层这么简单的情况下构建成一个庞大,复杂,却又安全的网络

* 于是你会发现很有趣的事实,就是网络中可能会存在多个数据包并行地向你传输,就像是千万滴水汇聚的河流一样,我们称这种通信中的数据包集合为一种"流"(flow)


#### 1.9 分层(Layering)

* 那么,简单输出一个结论/事实,"分层思想"在现代程序设计亦或是计算机设计中,绝对有着不可或缺的作用,你能看到数不胜数的程序基于分层思想进行设计,我们简单打个比方

![[image-7.png]]

* 如你所见,这是`Linux`的系统层级
* 如果你深入了解过`Linux`,那么一定很熟悉这个东西
* 分层设计思想,对于开发者亦或是用户来说,都是极为重要的思想
* 我们聊聊CS144中的例子
* 假设我想邮寄一本书给朋友,那么势必会通过以下几个步骤:
	1. 将书打包并贴好发件地址和收件地址
	2. 将书投放进邮筒,书会在邮筒中等待邮递员
	3. 邮递员取到书,将书给到我附近的邮件中转站
	4. 中转站会通过各种方式发往朋友附近的邮件中转站
	5. 朋友附近的邮件中转站则会派邮递员向朋友住址的邮箱投递邮件
	6. 邮件会在邮箱中等待直到,朋友拿到邮件
	7. 朋友确认邮件无误后进行拆包
	8. 朋友获得这本书

* 于是你会发现一个很有意思的事情
* 我们在发邮件的过程中,所有组成部分只需要干好自己的活就行,我们无需关心底层究竟是怎样运作的

* 我们放在网络中,就是四层分层,放在`OS`中,就是图中展示的这六层

* 另一个有趣的事实是,一旦某个组件需要进行更新,那么其余所有的层其实都不需要变化,所以分层能让功能之间解耦
* 但同时也有缺点,你会发现如果有了分层,虽然对于用户而言,隐藏了绝大部分的底层信息,对用户而言降低了复杂性与学习成本,但实际上这样做会极大地损失灵活性,这里我们聊聊CS144课程的另一个例子

* 如果你使用过`Python`或者说`Java`之类的语言,你会发现很多接口都全部封装好了,所有的底层细节用户都不必了解,用户只需要知道怎么使用顶层接口就行了
* 但C语言则完全不一样,你甚至可以在`.c`文件中穿插汇编语言,因为比方说`Linux`的内核代码中,就会有部分代码是用汇编写的,因为C语言允许你更灵活地使用一些功能,这就使得C语言的灵活性非常高,理论上你可以用C语言手搓一个C++,亦或是Python,但相对的,很多东西都要手动造轮子,所有的底层细节都需要我去注意,这就导致开发效率低,学习成本直线上升
* 换句话说就是过渡的封装会降低复杂性,降低学习成本,但同时灵活性也会大大降低

* 我之前和一个很厉害的后端工程师聊过,他说做后端的最高境界,就是能管理好项目的所有后端服务以及做这些服务的人,他说服务和服务之间有着很复杂的依赖关系,这种将项目拆分成各个服务,并进行层层依赖,本质上也是分层思想的具体体现


#### 1.10 封装(Encapsulation)

* 在网络中,封装也是一种常见思想
* 这里我们可以说得简单一些,因为在学习语言的过程中,我们或多或少学习过该思想

* 我们知道,一个`massage`,或者说数据,会从`Application`层层封装到`Link`,就像是这样
![[Pasted image 20250905110009.png]]

* 因为有这样的封装,所以每到一个设备中,该设备就只需要访问自己该访问的部分,就像是路由器,它只需要访问在`Network`和`Link`封装的头和尾,其他关于`massage`或者是其他层的细节不需要知道,依旧是解耦的思想,简单傻瓜易维护,但是不灵活
![[Pasted image 20250905110022.png]]

* 这里我们可以了解一个技术,当然这个技术的名字我们肯定是知道的,但具体做了什么,我们曾经可能从来没有了解过,这里我们借用这个技术来感受一下封装的优势
* 假设我们想在外部网络访问公司内网的服务器,我们可以在公司放一个既接通了外部网络,又连接公司内网的中继服务器
* 我们发送一个这样的包给中继服务器
![[Pasted image 20250905111735.png]]

* 对于中继服务器而言,他不知道具体要转发什么内容,他只知道接收的这个`packet`的`massage`中,存放了一个完整的`packet`,他要将这个"内部"`packet`解析一下,然后转发到内部网络
* 这种技术叫做"虚拟专用网络隧道"(Virtual Private Network,也就是我们知道的`VPN`技术)

#### 1.11 `IPv4`地址

* 相信你一定在某些电子游戏中遇见过要用`IP`地址访问某个服务器的情况,当然,你肯定知道这个`IP`地址代表着某一台服务器,不同服务器的地址是不一样的,而本小节将会详细解读一下`IPv4`地址的构成

* `IPv4`地址是由`32`个`bit`构成的一串数字,我们看`IPv4`地址的时候要将其按`8bit`拆分成4各部分看,即`a.b.c.d`的形式
* 这意味着一个`IP`地址最大可以是`255.255.255.255`,也可以是`0.0.0.0`

* 比方说`192.168.0.100`,`25.66.10.1`,`172.45.0.111`,这些都是一个`IPv4`地址

* 另一个值得要注意的东西叫子网掩码,他和我们在用的`IP`有很大的联系
* 我们输入以下命令会返回一堆东西,我们可以慢慢看(为了服务器的安全,我还是得打一下码的)
```shell
oldking@iZwz9b2bj2gor4d8h3rlx0Z:~/CS144-2024-winter-backup$ ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 1o.x.x.x  netmask 255.x.x.x  broadcast 1x.x.x.x
        inet6 x::x:x:x:x  prefixlen x  scopeid 0x20<link>
        ether x:x:x:x:x:x  txqueuelen 1000  (Ethernet)
        RX packets 35883058  bytes 6550064423 (6.5 GB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 34958182  bytes 8303867503 (8.3 GB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

* 我这个阿里云服务器有两个地址,一个`IPv4`,一个`IPv6`
* 其中`1o.x.x.x`就是`IPv4`地址,`255.x.x.x`则是子网掩码

* 子网掩码这个东西怎么用?我来实例一下
* 假设我的子网掩码是`255.255.255.0`,假设我的设备的`IPv4`地址是`192.168.1.100`,我舍友的设备的`IPv4`地址是`192.168.1.201`
* 那么将我的设备`IPv4`地址按位与(`&`)上子网掩码得到`192.168.1.0`,我室友的`IPv4`地址做同样操作,也会得到`192.168.1.0`,那么证明我们两台设备的在同一个位置下,则表示我们两个设备可以不经过路由器,可以直接进行连接通信

* 事实上,路由器在做转发的时候,也是会参考子网掩码的,他会优先选择可直连的设备转发

* 关于`IP`分配问题
* 最初,`IPv4`地址的分配其实规定得很死,`IPv4`地址被分为三个类别,其中具体的值被划分成了`Network`部分和`Host`部分

* 该图截自CS144课程
![[Pasted image 20250908103039.png]]

* `Network`部分表示所处在多大的网段,或者说处于同一区域下的`Host`有多少
* `Host`部分则表示具体的主机
* 换句话说,就是`Network`位数少就意味着`Host`位数多,表示该网段下的设备很多
* 换句话说,子网掩码就是一个"边界",用于划分哪个部分是`Network`,哪个部分是`Host`

* 关于网段,我们可以这样理解
* 我们知道公网`IP`其实是非常有限的,所以我们做不到为所有人都分配一个公网`IP`,那么该怎么让人人都用上网络呢?
* 于是我们可以在公网下搞一个私有地址,比方说我的小区的某个路由的公网`IPv4`地址是`205.104.36.5`,其中`205.104.36`表示`Network`部分,`.5`表示`Host`部分
* 表示这个设备是`205.104.36.0`这个区间中的第`5`个设备
* 但实际我们为每栋用户分配的却不是这个公网`IP`,因为公网`IP`有限,所以我们为整个小区分配了一个私有地址,这个私有地址`192.168.0.0`(`Network`部分),只有小区自己内部可以使用
* 所有的用户与公网的交流,全部通过这个拥有公网`IP`的路由器代为转发

* 所以,在这个场景中,`205.104.36.0`是一个"公有网段",而`192.168.0.0`则是一个私有的网段

* 但你一定也发现了一个问题,如果小区的网段是`205.104.36.0`,但我的小区只有`5`个路由,这不就导致有两百多个`Host`被浪费掉了吗?答案是,是的,全部被浪费掉了!

* 所以,当人们发现`IPv4`开始不太够用的时候,提出了一个新的方案,叫做`CIDR`(无类别域间路由, Classless Inter-Domain Routing)

* 这个方案让`Network`的长度可以不受原来的三种类型约束,而是可以自定义其长度,我们回到小区的例子来看看他是怎样做的
* 原先,小区分配的是`205.104.36.0`,表示该网段下可以分配大约两百多个公网`IP`设备,但现在我们知道该小区只有`5`个公网用的路由,于是我可以改成分配成`205.104.36.160/27`,这意味着这个网段可以分配`2^(32-27) = 32`个公网`IPv4`地址,换句话说,这个`/27`表示前`27`位属于`Network`,后面的`5`位表示`Host`地址,同时`/27`也代表着子网掩码,那第`5`个路由的`IP`可以表示为`205.104.36.5/27`

* 那么最后,我们来规范一下,类似于`205.104.36.0`这种,他一般只是被称为一个`IPv4`地址,但语义不明确,而类似于`205.104.36.0/24`这种,称为`CIDR`网络前缀

#### 1.12 最长前缀匹配(Longest Prefix Match, `LPM`)

* 前段时间我们聊过路由转发`packet`需要查路由表,寻找最匹配的路径进行转发,这里我们就来补全这个空缺,来深入聊一聊路由是如何做最匹配路径的寻找的

* 我们先来看看路由表的具体构造如何

| dest | link |
| :---: | :---: |
| 0.0.0.0/0 (default) | 1 |
| 172.10.0.0/16 | 1 |
| 172.10.8.0/24 | 2 |
| 26.64.0.0/16 | 2 |
| 79.0.0.0/8 | 3 |
| 13.230.9.0/24 | 2 |
| 174.25.0.0/16 | 4 |

* 其中,所有的`0`其实都表示此处是一个通配符,拿到的目标`IP`地址和该表中的地址后,依照子网掩码位数,比较最前位就可以找到最匹配的路径,如果没有最匹配的,就会走默认路由

* 我们举个例子,假设现在路由器拿到了一个`172.10.8.2`的包并需要将其转发
* 其中:
	1. 第一个地址不取任何数字,因为他是默认路由,一定是和需要转发的地址匹配的,然后做好记录,表示这个路径匹配过了
	2. 第二个地址取前`16`位和需要转发地址的前`16`位进行比较,发现也符合,那也把这个路径记录下来
	3. 第三个地址取前`24`位和需要转发地址的前`24`位进行比较,发现也符合,那也把这个路径记录下来
	4. 剩下的如法炮制...

* 于是最后发现,所有记录的`3`个匹配项中,`172.10.8.0/24`这个地址存在`24`位与需转发地址匹配,那么就会走`link 2`进行转发

#### 1.13 地址解析协议(Address Resolution Protocol, `ARP`)

* 在了解`ARP`之前,我们首先还需要了解一些前置知识

* 首先,`IP`地址是一个`Network`层地址,但实际传输却是在`Link`层传输,而`Link`层其实无权访问`Network`层的任何内容,所以势必的,`Link`层也需要有自己的"地址",这个地址我们称为`MAC`地址
* 另一个问题,公网`IP`地址其实不是物理意义上存在的,而是"受分配的",是虚拟的一个地址(只有某些互联网服务才可以申请某个固定的公网`IP`,造成这种受分配情况的原因还是因为`IPv4`地址太过于稀缺了),而`MAC`地址却是一个物理意义上存在的地址,是网卡出厂的时候就烧录进网卡的,所以理论上这个地址才是全球唯一的网卡地址
* 所以实际上,我们会将`datagram`在`Link`层中打包成帧,然后实际在`Link`层中转发的都是帧

* 另一个有意思的点是,一个路由器可以有多个网卡,并且可以有多个`IP`地址
* 首先我们要知道,因为路由器本质是在做转发操作,而一个网卡只能关联他所在的网段,所以如果我要从一个网段发送内容到路由器关联的另一个网段,就必须要用两个网卡

* 那么,以上是前置知识,现在我们将会举一个来自CS144的例子

1. A: 一台主机,`IP`地址为`192.168.10.100`,`mac`地址(用于辨认哪个网卡,属于链路层地址)为`AA:AA:AA:AA:AA:AA`
2. B: 一台主机,`IP`地址为`172.100.10.100`,`mac`地址(用于辨认哪个网卡,属于链路层地址)为`BB:BB:BB:BB:BB:BB` 
3. C: 一个网关,拥有两张网卡
	1. 一张网卡连接着A,该网卡的`IP`地址为`192.168.10.101`,mac地址为`CC:CC:CC:CC:CC:CC`
	2. 另一张网卡连着B,该网卡的地址为`172.100.10.101`,mac地址为`DD:DD:DD:DD:DD:DD`
	
* 那么,如果A需要发包给B,首先会参考子网掩码(A的子网掩码是`255.255.255.0`),但显然这里B不会和A在同一个网段下,那么此时A开始封装`packet`,源IP地址是A自己的,源`mac`地址也是A自己的,但目标IP地址是B的`IP`地址,目标`mac`地址是网关的`CC:CC:CC:CC:CC:CC` 发送帧给网关之后,网关会解包,并封装自己的`mac`地址(`DD:DD:DD:DD:DD:DD`)作为源`mac`地址放进帧的链路层中,还会封装B的`mac`地址作为目标`mac`地址放进帧的链路层中

* 这里这个网关其实就是路由啦

* 那么此时有一个很重要的问题出现了,A怎么知道网关的`mac`地址?当然不知道!所以我们需要`ARP`协议帮助我们获取网关的`mac`地址
* 此时,A会在当前网段中广播它所有能广播到的设备,向这些设备提问:"谁是`192.168.10.101`?告诉我你的`mac`地址!",那么C收到这个广播之后就会发回它的`mac`地址给A,此时A就可以正确封装`packet`了,然后发送到C手上,然后C也做同样的事情获取B的`mac`地址,然后发包给B

* 注意,这里是在广播所有能广播到的当前网段设备,这意味着?!
* 我们是不是可以欺骗这个A,让A以为我们是一个路由器,而实际上我们是另外一台主机?!
* 当然可以!
* A中将会维护一张表,映射C的`IP`和`mac`地址,只要在还没有实现映射的时候,抢在网关应答之前应答A,并把自己的`mac`地址当作一个网关`mac`地址发回给A,那么他就会把这个伪装的网关真的当作一个路由发包
* 恭喜你学会了`ARP`欺骗

